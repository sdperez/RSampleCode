library("pwr")
pwr.2p.test(h=c(2 3),power=.8,alternative="two.sided")
pwr.2p.test(h=c(2, 3),power=.8,alternative="two.sided")
pwr.2p.test(h=3,power=.8,alternative="two.sided")
pwr.2p.test(h=.3,power=.8,alternative="two.sided")
pwr.2p.test(h=.2,power=.8,alternative="two.sided")
pwr.2p.test(h=.2,power=c(.8,.85,.9),alternative="two.sided")
pwr.2p.test(h=.2,power=c(.8, .85, .9),alternative="two.sided")
pwr.2p.test(h=.2,power=c(.8 .9),alternative="two.sided")
pwr.2p.test(h=.2,power=c(.8),alternative="two.sided")
pwr.2p.test(h=.2,power=c(.8, .85),alternative="two.sided")
pwr.2p.test(h=.2,power=c(.85),alternative="two.sided")
library("Hmisc")
pwr.2p.test(h=.2,power=.80,alternative="two.sided")
pwr.2p.test(h=.2,power=.85,alternative="two.sided")
pwr.2p.test(h=.2,power=.90,alternative="two.sided")
pwr.2p.test(h=.3,power=.90,alternative="two.sided")
pwr.2p.test(h=.3,power=.85,alternative="two.sided")
pwr.2p.test(h=.3,power=.80,alternative="two.sided")
x<- matrix (1:4,2,2); y<-matrix(rep(10,4), 2,2) #creating two matrices
x
y
y<-matrix(rep(10,4), 2,2)
x
y
y<-matrix(rep(10, 4), 2,2)
x
y
x[1,2] #returns a VECTOR with the data in the 1st row second column
x[1,2,drop=FALSE] #returns a 2x2 matrix with only the above info (doesn't drop the extra columns/rows)
x<-list(foo=1:4, bar=.6)
x[1]
y<-x[1]
y<-X[[1]]
y<-x[[1]]
x[[1]]
x[["bar"]]
x[c(1,2)]
name<-"foo"
x[[name]]
x[[1]][[3]]
x[[c(1,3)]] #does the same
x[!is.na(x)]
x<-c(1,2,NA,4,NA,5)
x[!is.na(x)]
y<-c("a","b",NA,"d",NA,NA)
complete.cases(x,y) #returns all lines that have no missing data (in either field)
x[1:3][1]
x[1:3][2]
x[1:3][3]
x<-list(a=1:4,b=rnorm(10),c=rnorm(20,1))
x[[1]]
x[[2]]
x$c
lapply(x,mean) #lapply applies the function 'mean' to all elements of the list 'x'
x<-list(a=1:4,b=rnorm(10),c=rnorm(20,2)) # this creates a list with 3 vectors.
lapply(x,mean) #lapply applies the function 'mean' to all elements of the list 'x'
rnorm()
rnorm
str(rnorm)
x<- matrix (1:4,2,2)
y<-matrix(rep(10, 4), 2,2)
l<-list(x,y)
lapply(l,function(elt elt[,1])) #elt is defined here as selecting the first colum
lapply(l,function(elt) elt[,1])) #elt is defined here as selecting the first colum
lapply(l,function(elt) elt[,1]) #elt is defined here as selecting the first colum
x<-list(a=1:4,b=rnorm(10),c=rnorm(20,1)) # this creates a list with 3 vectors.
sapply(x,mean)
a<-array(rnorm(2*2*10),c(2,2,10)) #creates 40 random number and puts them in a 2x2x10 array
a
a
apply (a, c(1,2),mean) #gets the 'mean' of array 'a' summarized over the 3rd dimension (keeping dimension 1 and 2)
gl
str(gl)
x<-c(norm(10), runif(10), rnorm(10,1))# creates 30 random numbers from different distributions
f<-gl(3,10) #creates 3 factor levels and copies 10 times each.
x<-c(rnorm(10), runif(10), rnorm(10,1))# creates 30 random numbers from different distributions
f<-gl(3,10) #creates 3 factor levels and copies 10 times each.
tapply(x,f,mean)
library(datasets)
head(airquality)
lapply(s,function(x) colMeans(x[, c("Ozone","Solar.R", "Wind")]))
s<-split(airquality, airquality$Month) #split dataset by the variable month (gives a list)
lapply(s,function(x) colMeans(x[, c("Ozone","Solar.R", "Wind")]))
sapply(s,function(x) colMeans(x[, c("Ozone","Solar.R", "Wind")]))#returns a 3x5
d<-sapply(s,function(x) colMeans(x[, c("Ozone","Solar.R", "Wind")]))#returns a 3x5 matrix
sapply(s,function(x) colMeans(x[, c("Ozone","Solar.R", "Wind")], na.rm=TRUE))
library("pwr")
install.packages("pwr")
d<-c(rep(2,23),rep(3,50), rep(4,50))
fix(d)
sd(d)
mean(d)
